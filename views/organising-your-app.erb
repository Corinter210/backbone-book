<% @title = 'Organising your app' %>

<h1>
  Organising your app
</h1>

<p>
  Code organisation makes or breaks an app, and doing it right isn't just knowing how to separate models, collections, and views. That's the easy part. The part where most fail is knowing what should be separated from loading and runtime.
</p>

<p>
  The formula we'll use here is simple and yet very effective: we'll write a manifest file and a boot script. The manifest will pull all your scripts in (loading), and the boot script is where the base app classes/modules will be instanced (runtime).
</p>

<p>
  The boot script is especially important for keeping control over what gets used and when, so when writing a test case for a view, you'll want to load it, setup mocks for any models/collections it uses, instance it passing the mocks to it, and then test it's features, in this order. If loading a module means running it, it's <strong>a lot</strong> harder to do that.
</p>

<%= partial :- %>

<p>
  The manifest file is a list of scripts needed for your app to work. Things will really diverge here depending on what back-end or build system you are using.
</p>

<p>
  Rails uses <a href="https://github.com/sstephenson/sprockets">Sprockets</a>, which is also available on Sinatra through the <a href="https://github.com/kalasjocke/sinatra-asset-pipeline">sinatra-asset-pipeline</a> project, as well as being usable <a href="https://github.com/juliocesar/hopla.io/blob/master/Rakefile#L66">on it's own</a>. For JavaScript/node.js there's <a href="http://gruntjs.com/">Grunt</a>. Most Grunt workflows consist of writing a task declaring an array of files which will get concatenated into a single file.
</p>

<p>
  Regardless of the tooling you choose, both will achieve the same: take a bunch of files and turn them into one, the file you'll serve. With adequate caching set for both HTML and this script, and appending a digest to the script file name, your setup is pretty damn good.
</p>

<p>
  There's also an entirely different approach to this problem which is dynamically loading scripts as you need them, and the most popular tool for it is <a href="http://requirejs.org/">require.js</a>. By all means, check it out. It won't be covered here though.
</p>

<%= partial :- %>

<p>
  With Sprockets, an expanded manifest file looks like this. This is actually an excellent way to explain how it conceptually works, even if you're planning on using Grunt.
</p>

<pre class="language-coffeescript"><code># App scripts manifest
# ====================

# Dependencies.
#= require vendor/jquery
#= require vendor/underscore
#= require vendor/backbone

# Data layer.
#= require models/user
#= require models/book
#= require models/cart
#= require models/comment
#= require collections/books
#= require collections/comments

# Views.
#= require views/books/list
#= require views/books/show
#= require views/user/show
# …

# The router.
#= require router

# App boot script.
#= require boot</code></pre>

<p>
  Which should be refactored to this:
</p>

<pre class="language-coffeescript"><code># App scripts manifest
# ====================

# Dependencies.
#= require_tree ./vendor

# Data layer.
#= require_tree ./models
#= require_tree ./collections

# Views.
#= require_tree views

# The router.
#= require router

# App boot script.
#= require boot</code></pre>

<p>
  When Sprockets compiles this script, it'll inline all the files <code>require</code>d by it (and as you probably guessed, <code>require_tree</code> inlines a whole directory and subdirectories of scripts).
</p>

<p>
  In case it wasn't clear before: the boot script is loaded in the manifest as well. What matters is separating runtime logic from loading. Removing the boot script from the manifest will load everything, but nothing will happen. The modules will be loaded and available, but won't be used and they won't modify anything. That's the expected behaviour.
</p>

<%= partial :- %>

<p>
  When the boot script is loaded, it will run things, as in it'll instantiate classes, run module methods, and so on. So this script is the only one that will, when loaded, change the state of the app and the browser.
</p>

<p>
  You could argue that anything that puts a variable in the <code>window</code> scope is, technically, modifying the environment, and thus this is all garbage. But pragmatism is your friend: judiciously placing classes/modules in the global scope is fine, as it happens with nearly every other scripting language such as Python or Ruby (and incidentally not with node.js). The important part is not have a module <strong>do</strong> anything as it gets loaded.
</p>

<p>
  What a boot script will run, it depends on it's purpose. For really loading the app, you'll likely have it create collections that are shared among views, initialise the router and kick off <code>history</code> tracking, setup events that are to be broadcasted, and so on. For testing a specific view, for example, you'll likely leave all those out and only run what's necessary to set up it's test cases. It's easier to write a boot file for each purpose.
</p>

<pre class="language-coffeescript"><code># App boot script
# ===============
#
# Presuming that we're not using browserify to illustrate the point.

# Main app class.
window.BookStore = new App

# The user using the app.
BookStore.User = new User

# Shared collections.
BookStore.Books = new Books
BookStore.Articles = new Articles

# We'll use this &lt;body&gt; reference to put some views in it below.
$body = $ 'body'

# Views that will exist regardless of what URL you are.
header = new Header
$body.append header.render().el
menu = new MainMenu
$body.append menu.render().el

# A module for capturing global ajax errors.
GlobalErrors.initialize()

# A module for tracking and broadcasting page scrolling events.
Scrolling.initialize()

# The router. We usually don't need to keep a reference to it.
new Router

# Kick off the router code.
Backbone.history.start pushState: yes</code></pre>

<p>
  Some will argue views should always be built within the router (through a controller as we explained in the respective chapter). It depends on how you structure the application. The assumption here is those two views will always appear regardless of the URL you arrive in the app from, so it makes sense. And that's the only rule: it has to make sense and work well without ruining modularity and/or separation of concerns.
</p>

<%= partial :- %>

<p>
  There's an “export hack” you should write in every script. It goes like this:
</p>

<pre class="language-coffeescript"><code># Book list view
# ==============

class BookList extends Backbone.View
  # …
  # …
  # …

(module?.exports = BookList) or @BookList = BookList</code></pre>

<p>
  That last line will check for the existence of the <code>module</code> keyword, and if it exists, it'll assign the <code>BookList</code> object to it. Or if <code>module</code> does not exist, assign <code>BookList</code> to the global scope. This ensures regardless of whether you're using a module system or just loading the script as is, the end result is the product is always where you expect it to be.
</p>

<p>
  And always do that separately from the class/module declaration itself.
</p>

<%= partial :- %>

Passing server data to a JS app as a good thing. i.e.: don't do what Twitter did and failed at it.
